---
layout: post
title: Makefile tutorial 2.0
categories: [tutorials]
---

This tutorial is an extention and refinement of my previous Makefile tutorial.
New concepts such as folder management, handy functions, and how to make your
output stylish will be covered.

## The basics

<div class="chapter" markdown="1" data-chapter="basic">

It's highly recommend for anyone reading to following along. Get started by
cloning this repo:

```sh
git clone https://git.sr.ht/~nloomans/makefile-tutorial
```

This repository includes the following `Makefile`:

```makefile
foo: main.o greeter.o
	gcc -o foo main.o greeter.o

main.o: main.c
	gcc -c -Wall -Wextra -Werror -o main.o main.c

greeter.o: greeter.c
	gcc -c -Wall -Wextra -Werror -o greeter.o greeter.c
```

This Makefile consists of 3 _rules_. A rule consists of a _target_, any
amount of _prerequisites_, and finally a _recipe_. The syntax is as follows:

```makefile
target: prerequisites
	recipe
```

A rule descibes how `make` can make something. The first rule with a _target_ of
`foo` describes how we can link together our executable. The second & third
rules describe how to compile the invidual object files.

When you run `make foo`, make will look for a rule which can compile `foo`, in
this case the first rule. Before executing the _recipe_, make will first figure
out if the _recipe_ needs to be run at all, and if any other rules need to be
executed first. Make first checks if every individual _prerequisite_ exists and
is up-to-date.

The `main.o` _prerequisite_ will not exist on the first run. Make will look
through the rules to find one with a compatible _target_. In this case this is
the `main.o` rule. For this rule, the same process will start over again - as if
you ran `make main.o`. Make sees that `main.c` exists and `main.o` does not. It
will therefor compile `main.o` by executing the _recipe_. If however, `main.o`
were to already be present, then make would compare the edit dates. If `main.c`
is more recent than `main.o`, make will act as if `main.o` does not exist, and
recompile it.

On the first run, the same thing would happen for `greeter.o`.

> **Exercise**: Compile the `foo` binary using make. Then compile it again. Now,
> change `main.c` a bit and compile `foo` again. Take note of what commands make
> executes.

> **Question**: You ran `make foo` 3 times, during which instances did
> `greeter.o` get compiled?
>
> <input type="radio" name="chapter-basic" id="chapter-basic-1" value="wrong-1">
> <label for="chapter-basic-1">All 3 instances</label><br>
> <input type="radio" name="chapter-basic" id="chapter-basic-2" value="wrong-2">
> <label for="chapter-basic-2">The first and third</label><br>
> <input type="radio" name="chapter-basic" id="chapter-basic-3" value="correct">
> <label for="chapter-basic-3">Only the first</label><br>

<div class="explain-wrong" data-for="wrong-1 wrong-2" style="display: none;" markdown="1">

**Wrong!** Make only executes a _recipe_ if **either** of the following
conditions is matched:

- There exists no file called _target_
- _target_ exists, but one of the _prerequisites_ is newer

During the first instance, all _recipies_ will be executed. During the second
instance, no _recipe_ will be executed as all _targets_ already exist and all
_prerequisites_ are older than the _targets_. During the third instance, only
`main.o` and `foo` got compiled. Because `greeter.o` was newer than `greeter.c`,
no attempt to recompile `greeter.o` was made.

</div>

</div>

## Variables and pattern matching

<div class="chapter" markdown="1" data-chapter="pattern-matching" data-prerequisite="basic">

Writing a new rule for every object file is cumbersome and error-prone. One
can write the previous `Makefile` much cleaner like this:

```makefile
foo: main.o greeter.o
	gcc -o $@ $^

%.o: %.c
	gcc -c -Wall -Wextra -Werror -o $@ $^
```

This Makefile functions exactly[^1] the same as the first Makefile.

The `%.o` rule will now handle the compilation of all object files. The `%` is
a pattern match. This is what the GNU Makefile manual says about pattern
matching, in [10.5.4 How Patterns Match](https://www.gnu.org/software/make/manual/make.html#Pattern-Match):

> A target pattern is composed of a ‘%’ between a prefix and a suffix, either or
> both of which may be empty. The pattern matches a file name only if the file
> name starts with the prefix and ends with the suffix, without overlap. The
> text between the prefix and the suffix is called the stem. Thus, when the
> pattern ‘%.o’ matches the file name test.o, the stem is ‘test’. The pattern
> rule prerequisites are turned into actual file names by substituting the stem
> for the character ‘%’. Thus, if in the same example one of the prerequisites
> is written as ‘%.c’, it expands to ‘test.c’.

That was quite a blob of text, let´s give an example. When make tries to
search for a rule to compile `main.o` with, it will match the pattern. The
_stem_, `main`, is then injected in `%.c` to become `main.c`. Effectively, make
will pretend that the _target_ is `main.o` and the _prerequisite_ is `main.c`.
The same is true for `greeter.o`, and any other file ending in `.o`. Note that
`%` is not a preprocessor statement. This all happens during runtime, and
therefor also works on files which have never been referenced in the Makefile.

The new version of our Makefile also contains two so-called
_automatic variables_. Namely `$@` and `$^`. These variables allow us to write
generic _recipes_ that work pattern matched rules. `$@` resolves to the _target_
and `$^` resolves to all of the _prerequisites_.

> **Question**: There is an aditional `stray.c` included in the example repo.
> Using the above Makefile, what would happen if we were to execute
> `make stray.o`?
>
> <input type="radio" name="chapter-pattern-matching" id="chapter-pattern-matching-1" value="wrong-1">
> <label for="chapter-pattern-matching-1"><code>make: *** No rule to make target 'stray.o'.  Stop.</code></label><br>
> <input type="radio" name="chapter-pattern-matching" id="chapter-pattern-matching-2" value="wrong-2">
> <label for="chapter-pattern-matching-2">Make compiles <code>stray.o</code> and links it into <code>foo</code></label><br>
> <input type="radio" name="chapter-pattern-matching" id="chapter-pattern-matching-3" value="correct">
> <label for="chapter-pattern-matching-3">Make compiles <code>stray.o</code> and does nothing else</label><br>

<div class="explain-wrong" data-for="wrong-1" style="display: none;" markdown="1">

**Wrong!** The `%` is not a preprocessor statement. When you write
`make stray.o`, make will check each rule, one by one, to see if they can make
`stary.o`. The rule with a _target_ of `%.o` is able to make `stray.o`.

</div>

<div class="explain-wrong" data-for="wrong-2" style="display: none;" markdown="1">

**Wrong!** While `stray.o` will be compiled, the `foo` rule will never be
executed. The `foo` rule will only be used by make if you explictely write
`make foo`, or if you just write `make` on its own, which causes make to use the
first rule.

</div>

</div>

## Variables

<div class="chapter" markdown="1" data-chapter="variables" data-prerequisite="pattern-matching">

Until now we wrote things like the list of object files and which flags gcc
takes inline. This is fine for small Makefiles, but let's clean it up a bit:

```makefile
NAME := foo
OBJFILES := main.o greeter.o
CFLAGS ?= -Wall -Wextra -Werror

$(NAME): $(OBJFILES)
	$(CC) $(LDFLAGS) -o $@ $^

%.o: %.c
	$(CC) -c $(CFLAGS) -o $@ $^
```

The variables set with `:=` are always set unconditionally. Variables set with
`?=` are only set if it hasn't been set already. Make inherits variables from
environment variables. This allows us to easily run make with custom `CFLAGS`
like so:

```sh
# Compile the program in debug mode (-g), and don't stop compiling on
# warnings.
CFLAGS="-Wall -Wextra -g" make
```

The `CC` variable is a bit special in that it is [pre-defined] to `cc`. The idea
is simple, if you write standard complient code, why should you specify with
which compiler to compile your code with? `cc` is the default C compiler on most
systems, and if the user wants your program to be compiled with a different
compiler, they can set the `CC` variable:


```sh
# Use the clang compiler and compile with the clang spesific
# -fsanitize=address option to detect memory corruption.
export CC=clang
export CFLAGS="-Wall -Wextra -g -fsanitize=address"
export LDFLAGS="-g -fsanitize=address"
make
```

[pre-defined]: https://www.gnu.org/software/make/manual/make.html#Implicit-Variables

</div>

---

[^1]: One minor difference, the second rule will now match _any_ `.o` file,
      not just `main.o` and `greeter.o`.

<script>
const namespace = "markdown-tutorial-v2";
const chapters = document.querySelectorAll(".chapter");
console.log(chapters);

function restoreAnswers() {
	for (let chapter of chapters) {
		const chapterID = chapter.dataset.chapter;
		const answer = window.localStorage.getItem(`${namespace}-chapter-${chapterID}`);
		if (answer !== null) {
			chapter.querySelector(`input[value="${answer}"]`).checked = true;
		}
	}
}

function checkAnswers() {
	for (let chapter of chapters) {
		const chapterID = chapter.dataset.chapter;
		const checked = document.querySelector(`input[name="chapter-${chapterID}"]:checked`);
		if (checked === null) {
			continue;
		}

		window.localStorage.setItem(`${namespace}-chapter-${chapterID}`, checked.value);
	}

	updateDocument();
}

function displayExplainer(chapter, wrongAnswer) {
	const explainers = chapter.querySelectorAll(".explain-wrong");
	for (let explainer of explainers) {
		explainer.style.display = "none";
	}

	if (wrongAnswer !== null) {
		const explainerToShow = chapter.querySelector(`.explain-wrong[data-for~="${wrongAnswer}"]`);
		explainerToShow.style.display = "block";
	}
}

function updateDocument() {
	for (let chapter of chapters) {
		const parent = chapter.parentElement;
		const chapterID = chapter.dataset.chapter;
		const prerequisite = chapter.dataset.prerequisite;

		const answer = window.localStorage.getItem(`${namespace}-chapter-${chapterID}`);
		if (answer === "correct") {
			displayExplainer(chapter, null);
		} else {
			displayExplainer(chapter, answer);
		}

		if (prerequisite === undefined) {
			continue;
		}

		const answerOfPrerequisite = window.localStorage.getItem(`${namespace}-chapter-${prerequisite}`);
		if (answerOfPrerequisite === "correct") {
			const notice = document.querySelector(`#${namespace}-notice-${chapterID}`);
			if (notice !== null) {
				parent.removeChild(notice);
			}

			chapter.style.display = "block";
		} else {
			if (document.querySelector(`#${namespace}-notice-${chapterID}`) === null) {
				const notice = document.createElement("p");
				notice.id = `${namespace}-notice-${chapterID}`;
				notice.innerHTML = "<em>[complete above exercise to view]</em>";
				parent.insertBefore(notice, chapter);
			}

			chapter.style.display = "none";
		}
	}
}

restoreAnswers();
updateDocument();
document.querySelectorAll('.chapter input[type="radio"]')
	.forEach(input => input.addEventListener("change", checkAnswers));
</script>
